/**
 * Enhanced UI Components for Superior Terminal Experience
 * Modern, interactive, and visually appealing interface elements
 */
import chalk from 'chalk';
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
// Enhanced imports with fallbacks
let gradientString;
let terminalKit;
try {
    const gradientModule = require('gradient-string');
    gradientString = gradientModule.default || gradientModule;
}
catch (e) {
    gradientString = null;
}
try {
    const terminalKitModule = require('terminal-kit');
    terminalKit = terminalKitModule.default || terminalKitModule;
}
catch (e) {
    terminalKit = null;
}
export class EnhancedUIComponents {
    /**
     * Beautiful gradient banner with animation
     */
    static showAnimatedBanner() {
        const bannerText = `
    ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
    ‚îÇ                                                         ‚îÇ
    ‚îÇ  ü§ñ  Multi-Provider ChatBot CLI  ‚ö°                     ‚îÇ
    ‚îÇ                                                         ‚îÇ
    ‚îÇ     üöÄ Intelligent ‚Ä¢ üí™ Powerful ‚Ä¢ üéØ Simple         ‚îÇ
    ‚îÇ                                                         ‚îÇ
    ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
    `;
        if (gradientString) {
            const rainbow = gradientString('cyan', 'magenta', 'yellow', 'green');
            console.log(rainbow(bannerText));
        }
        else {
            console.log(chalk.cyan(bannerText));
        }
    }
    /**
     * Enhanced status bar with real-time updates
     */
    static showLiveStatusBar(info) {
        const statusIcons = {
            online: 'üü¢',
            offline: 'üî¥',
            error: 'üî¥',
            connecting: 'üü°',
            streaming: 'üîµ'
        };
        const providerIcons = {
            'gemini': 'üß†',
            'deepseek': 'ü§ñ',
            'ollama': 'ü¶ô',
            'openai': 'üî•'
        };
        const statusLine = [
            chalk.bold.white('‚óâ Live Status'),
            chalk.gray('‚îÇ'),
            `${statusIcons[info.status] || '‚ö™'} ${info.status === 'online' ? chalk.bold.green(info.status) : chalk.bold.red(info.status)}`,
            chalk.gray('‚îÇ'),
            `${providerIcons[info.provider] || 'üîπ'} ${chalk.cyan.bold(info.provider)}`,
            chalk.gray('‚îÇ'),
            `‚öôÔ∏è  ${chalk.magenta(info.model)}`,
            chalk.gray('‚îÇ'),
            `üîß ${chalk.yellow(info.tools || 0)} tools`,
            chalk.gray('‚îÇ'),
            `‚ö° ${chalk.green(info.responseTime || 0)}ms`
        ].join(' ');
        // Create animated border
        const border = '‚ïê'.repeat(80);
        console.log(chalk.cyan(`‚ï≠‚îÄ${border}‚îÄ‚ïÆ`));
        console.log(chalk.cyan(`‚îÇ ${statusLine.padEnd(80)} ‚îÇ`));
        console.log(chalk.cyan(`‚ï∞‚îÄ${border}‚îÄ‚ïØ`));
    }
    /**
     * Chat message display with enhanced formatting
     */
    static displayMessage(message) {
        const timestamp = message.timestamp.toLocaleTimeString();
        const roleColors = {
            user: 'cyan',
            assistant: 'green',
            system: 'yellow'
        };
        const roleIcons = {
            user: 'üë§',
            assistant: 'ü§ñ',
            system: '‚öôÔ∏è'
        };
        const roleColor = roleColors[message.role] || 'white';
        const icon = roleIcons[message.role] || 'üí¨';
        // Header with role and timestamp
        const header = [
            chalk[roleColor].bold(`${icon} ${message.role.toUpperCase()}`),
            chalk.gray(`[${timestamp}]`),
            ...(message.tokens ? [chalk.blue(`${message.tokens} tokens`)] : []),
            ...(message.responseTime ? [chalk.green(`${message.responseTime}ms`)] : [])
        ].join(' ');
        console.log(header);
        // Message content with proper formatting
        const content = message.content.split('\n').map(line => {
            if (line.trim().startsWith('```')) {
                return chalk.gray(line);
            }
            else if (line.trim().startsWith('# ')) {
                return chalk.bold.white(line);
            }
            else if (line.trim().startsWith('## ')) {
                return chalk.bold.cyan(line);
            }
            else if (line.trim().startsWith('- ')) {
                return chalk.yellow('‚Ä¢ ') + chalk.white(line.slice(2));
            }
            return chalk.white(line);
        }).join('\n');
        console.log(content);
        console.log(chalk.gray('‚îÄ'.repeat(60)));
    }
    /**
     * Interactive command palette
     */
    static showCommandPalette() {
        const commands = [
            { cmd: '/help', desc: 'Show all available commands', icon: '‚ùì' },
            { cmd: '/setup', desc: 'Configure providers and settings', icon: '‚öôÔ∏è' },
            { cmd: '/switch <provider>', desc: 'Switch to different provider', icon: 'üîÑ' },
            { cmd: '/stream <message>', desc: 'Get streaming response', icon: '‚ö°' },
            { cmd: '/save', desc: 'Save current conversation', icon: 'üíæ' },
            { cmd: '/load', desc: 'Load previous conversation', icon: 'üìÅ' },
            { cmd: '/providers', desc: 'Show available providers', icon: 'üè¢' },
            { cmd: '/tools', desc: 'Show available tools', icon: 'üîß' },
            { cmd: '/clear', desc: 'Clear conversation history', icon: 'üßπ' },
            { cmd: '/exit', desc: 'Exit the application', icon: 'üëã' }
        ];
        console.log(chalk.bold.cyan('\nüìã Command Palette'));
        console.log(chalk.cyan('‚îÄ'.repeat(50)));
        commands.forEach(({ cmd, desc, icon }) => {
            console.log(`  ${icon} ${chalk.cyan.bold(cmd.padEnd(20))} ${chalk.white(desc)}`);
        });
        console.log(chalk.cyan('‚îÄ'.repeat(50)));
        console.log(chalk.gray('üí° Tip: Type any command followed by Enter to execute'));
    }
    /**
     * Provider selection with visual cards
     */
    static showProviderCards(providers) {
        console.log(chalk.bold.cyan('\nüè¢ Available Providers'));
        console.log(chalk.cyan('‚îÄ'.repeat(60)));
        providers.forEach(provider => {
            const statusIcon = provider.status === 'online' ? 'üü¢' : 'üî¥';
            const card = [
                chalk.bold.white(`${statusIcon} ${provider.name.toUpperCase()}`),
                chalk.gray(`Model: ${provider.model}`),
                chalk.white(provider.description)
            ].join('\n');
            console.log(`‚ï≠‚îÄ${'‚îÄ'.repeat(25)}‚îÄ‚ïÆ`);
            console.log(`‚îÇ ${card.split('\n').map(line => line.padEnd(25)).join(' ‚îÇ\n‚îÇ ')} ‚îÇ`);
            console.log(`‚ï∞‚îÄ${'‚îÄ'.repeat(25)}‚îÄ‚ïØ`);
        });
    }
    /**
     * Streaming response with live updates
     */
    static showStreamingResponse(initialMessage = 'AI is thinking...') {
        let currentText = '';
        let dots = 0;
        const spinner = {
            interval: null,
            start: () => {
                console.log(chalk.blue(`ü§ñ Assistant: ${chalk.gray('(streaming...)')}`));
                process.stdout.write(chalk.green('‚ñ∫ '));
            },
            addText: (text) => {
                currentText += text;
                process.stdout.write(chalk.white(text));
            },
            complete: (stats) => {
                console.log(); // New line
                if (stats) {
                    console.log(chalk.gray(`   ‚ö° ${stats.responseTime}ms ‚Ä¢ üìä ${stats.tokens} tokens`));
                }
                console.log(chalk.gray('‚îÄ'.repeat(60)));
            },
            error: (errorMessage) => {
                console.log(chalk.red(`\n‚ùå Error: ${errorMessage}`));
                console.log(chalk.gray('‚îÄ'.repeat(60)));
            }
        };
        return spinner;
    }
    /**
     * Session overview dashboard
     */
    static showSessionDashboard(session) {
        const duration = new Date().getTime() - session.startTime.getTime();
        const durationStr = `${Math.floor(duration / 60000)}m ${Math.floor((duration % 60000) / 1000)}s`;
        console.log(chalk.bold.cyan('\nüìä Session Dashboard'));
        console.log(chalk.cyan('‚ïê'.repeat(50)));
        const stats = [
            ['üÜî Session ID', session.sessionId],
            ['‚è±Ô∏è  Duration', durationStr],
            ['üí¨ Messages', session.messageCount.toString()],
            ['üî§ Total Tokens', session.totalTokens.toString()],
            ['ü§ñ Provider', session.provider],
            ['‚öôÔ∏è  Model', session.model]
        ];
        stats.forEach(([label, value]) => {
            console.log(`  ${chalk.white(label.padEnd(15))} ${chalk.cyan(value)}`);
        });
        console.log(chalk.cyan('‚ïê'.repeat(50)));
    }
    /**
     * Enhanced error display with suggestions
     */
    static showEnhancedError(error, suggestions = []) {
        console.log(chalk.red.bold('\n‚ùå Error Occurred'));
        console.log(chalk.red('‚îÄ'.repeat(40)));
        console.log(chalk.white(`  ${error}`));
        if (suggestions.length > 0) {
            console.log(chalk.yellow('\nüí° Suggestions:'));
            suggestions.forEach(suggestion => {
                console.log(chalk.gray(`  ‚Ä¢ ${suggestion}`));
            });
        }
        console.log(chalk.red('‚îÄ'.repeat(40)));
    }
    /**
     * Loading animation with progress
     */
    static showLoadingAnimation(message = 'Processing...') {
        const frames = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è'];
        const colors = ['cyan', 'blue', 'magenta', 'green', 'yellow', 'red'];
        let frameIndex = 0;
        let colorIndex = 0;
        const loader = {
            interval: null,
            start: () => {
                loader.interval = setInterval(() => {
                    const frame = frames[frameIndex];
                    const color = colors[colorIndex];
                    process.stdout.write(`\r${chalk[color](frame)} ${chalk.gray(message)}`);
                    frameIndex = (frameIndex + 1) % frames.length;
                    if (frameIndex === 0) {
                        colorIndex = (colorIndex + 1) % colors.length;
                    }
                }, 100);
            },
            stop: () => {
                if (loader.interval) {
                    clearInterval(loader.interval);
                    process.stdout.write('\r' + ' '.repeat(message.length + 3) + '\r');
                }
            },
            succeed: (successMessage) => {
                loader.stop();
                console.log(chalk.green(`‚úÖ ${successMessage}`));
            },
            fail: (errorMessage) => {
                loader.stop();
                console.log(chalk.red(`‚ùå ${errorMessage}`));
            }
        };
        return loader;
    }
    /**
     * Interactive progress bar
     */
    static showProgressBar(current, total, message = '') {
        const percentage = Math.round((current / total) * 100);
        const filled = Math.round((current / total) * 30);
        const empty = 30 - filled;
        const progressBar = [
            chalk.green('‚ñà'.repeat(filled)),
            chalk.gray('‚ñë'.repeat(empty))
        ].join('');
        const progressText = [
            chalk.cyan('Progress:'),
            `[${progressBar}]`,
            chalk.yellow(`${percentage}%`),
            chalk.gray(`(${current}/${total})`),
            ...(message ? [chalk.dim(message)] : [])
        ].join(' ');
        process.stdout.write('\r' + progressText);
        if (current >= total) {
            process.stdout.write('\n');
            console.log(chalk.green('‚úÖ Complete!'));
        }
    }
    /**
     * Clear screen with fade effect
     */
    static clearScreenWithFade() {
        // Simple clear for now - can be enhanced with terminal-kit
        console.clear();
        this.showAnimatedBanner();
    }
    /**
     * Show typing indicator
     */
    static showTypingIndicator(name = 'Assistant') {
        const dots = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è'];
        let index = 0;
        const indicator = {
            interval: null,
            start: () => {
                indicator.interval = setInterval(() => {
                    process.stdout.write(`\r${chalk.gray(dots[index])} ${chalk.blue(name)} is typing...`);
                    index = (index + 1) % dots.length;
                }, 100);
            },
            stop: () => {
                if (indicator.interval) {
                    clearInterval(indicator.interval);
                    process.stdout.write('\r' + ' '.repeat(30) + '\r');
                }
            }
        };
        return indicator;
    }
    /**
     * Quick stats display
     */
    static showQuickStats(stats) {
        console.log(chalk.bold.cyan('\nüìà Quick Stats'));
        console.log(chalk.cyan('‚îÄ'.repeat(30)));
        Object.entries(stats).forEach(([key, value]) => {
            console.log(`  ${chalk.white(key.padEnd(15))} ${chalk.cyan(value)}`);
        });
        console.log(chalk.cyan('‚îÄ'.repeat(30)));
    }
}
//# sourceMappingURL=EnhancedUIComponents.js.map